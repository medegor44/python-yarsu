# Лабораторная работа 1

Вам необходимо смоделировать одну из четырех предметных областей

# Вариант 1 "Трекер привычек"
## Цель
Смоделировать простой трекер ежедневных привычек: создать привычку и отмечать выполнение по дням.


## Обязательные операции
- Система должна позволять завести новую привычку с уникальным (регистр учитывается по вашему выбору, но надо оговорить) непустым названием и положительной целевой нормой на день (целое число больше нуля). При попытке добавить уже существующую — сообщить об ошибке.
- Должна быть возможность получить перечень всех заведённых привычек вместе с их дневными целями (формат представления на усмотрение автора: список строк, структур, словарь и т.п.).
- Должна быть возможность фиксировать выполнение привычки за конкретную календарную дату (формат даты оговорить, рекомендуемый — строка YYYY-MM-DD). Если за один день для той же привычки поступают несколько фиксаций, суммарное выполненное значение за день накапливается. Фиксируемая величина всегда должна быть положительной; неверные значения отклоняются.
- Должна быть возможность узнать прогресс конкретной привычки за выбранную дату: вернуть фактически выполненный объём за день, целевое значение и процент выполнения. Процент вычисляется как (выполнено / цель * 100) и не должен отображаться выше 100%, даже если перевыполнено. При этом само хранимое "перевыполнено" не урезается.
- Должна быть возможность получить суммарный накопленный объём выполнения по привычке за все зарегистрированные дни (без вычисления процента — просто сумма).

## Допущения
- Хранение можно реализовать в памяти (без файлов и баз данных).

## Опционально (Nice to have)
- Удаление или "сброс" привычки.
- Сброс данных за день.
- Подсчёт текущей серии дней, где цель достигалась (streak).
- Короткий отчёт по всем привычкам за "сегодня".

## Пример ожидаемого сценария
```python
# Пример использования
tracker = HabitTracker()
tracker.add_habit("Чтение", 1)
tracker.add_habit("Отжимания", 20)

tracker.mark("Отжимания", "2025-09-13", 15)
tracker.mark("Отжимания", "2025-09-13", 10)  # итого 25 (перевыполнение допустимо)

print(tracker.get_day_progress("Отжимания", "2025-09-13"))
# -> {'done': 25, 'target': 20, 'percent': 100}

print(tracker.get_total("Отжимания"))
```

## Критерий приемки
- Все перечисленные обязательные возможности реализованы.
- Процент никогда не превышает 100.
- Ошибочные случаи обрабатываются (не молча).
- Код структурирован: отдельный объект для привычки и отдельный объект/модуль для управления коллекцией.
---

# Вариант 2: "Система аренды велосипедов"
Предметная область: Пункт проката: обычные, электрические, тандемы.

## Цель
Смоделировать пункт проката нескольких видов велосипедов

## Обязательные операции 
- Система должна позволять добавить новый велосипед в пункт проката, указав его уникальный идентификатор, тип (например, обычный, электрический, тандем) и базовую стоимость аренды за час. Попытка добавить велосипед с уже существующим идентификатором должна приводить к ошибке.
- Должна быть возможность получить перечень всех доступных велосипедов с их характеристиками (идентификатор, тип, стоимость аренды). Формат представления - на усмотрение автора.
- Система должна позволять оформить аренду велосипеда на определённое количество часов. При этом необходимо фиксировать, что велосипед выдан и временно недоступен для других клиентов. Если попытаться арендовать уже выданный велосипед, система должна сообщить об ошибке.
- Для каждого типа велосипеда стоимость аренды может рассчитываться по-разному:
  - Для обычного велосипеда — базовая ставка за час.
  - Для электрического — базовая ставка плюс фиксированная доплата за использование батареи.
  - Для тандема — базовая ставка умножается на коэффициент (например, 1.5).
- Формулы расчёта стоимости должны быть реализованы так, чтобы при добавлении новых типов велосипедов не приходилось переписывать существующий код расчёта.
- Должна быть возможность вернуть велосипед из аренды, после чего он снова становится доступен для новых клиентов.
- Система должна позволять узнать итоговую стоимость аренды для конкретного заказа (учитывая тип велосипеда и продолжительность аренды).

## Допущения
- Хранение можно реализовать в памяти (без файлов и баз данных).

## Опционально (Nice to have)
- Добавить учёт клиентов (имя, id).
- Вести историю всех аренд.
- Реализовать скидки или специальные тарифы.
- Короткий отчёт по текущим арендованным велосипедам.

## Пример ожидаемого сценария
```python
service = RentalService()

# Добавляем велосипеды
service.add_bike(Bike("id1"))
service.add_bike(Bike("id2"))

print("Доступно сначала:", service.list_available())

# Аренда электрического на 3 часа
rental_id = service.start_rental("e1", hours=3)
print("Стоимость аренды e1 (3ч):", service.get_rental_cost(rental_id))  # 3*150 + 50 = 500

# Попытка взять его снова
try:
    service.start_rental("e1", 1)
except BikeAlreadyRentedError:
    print("Ожидаемо: e1 уже в аренде")

# Завершение аренды
service.finish_rental(rental_id)

# Повторная аренда теперь возможна
service.start_rental("e1", 1)

print("Доступно после операций:", service.list_available())
```

## Критерий приемки
- Все перечисленные обязательные возможности реализованы.
- Ошибочные случаи обрабатываются явно.
- Код структурирован: отдельные объекты для велосипеда и для управления арендой.
- Стоимость аренды рассчитывается корректно для всех типов велосипедов.
---

# Вариант 3: "Платформа онлайн курсов"

Предметная область: Построение онлайн курса, отслеживание прогресса пользователя по прохождению этого курса

## Цель
Смоделировать платформу онлайн курсов

## Обязательные операции 
- Система должна позволять создать учебный курс с уникальным названием и добавить в него учебные единицы разных типов (например: текстовый урок, тестовый блок с вопросами). Порядок элементов внутри курса должен сохраняться.
- Должна быть возможность получить структурированное представление содержимого курса (в исходном порядке), включая тип каждого элемента и его заголовок/краткое описание. Формат вывода - на усмотрение автора.
- Должна быть возможность зарегистрировать пользователя (уникальный идентификатор + имя). Повторная регистрация с уже занятым идентификатором должна приводить к ошибке.
- Пользователь должен иметь возможность "начать прохождение" конкретного курса; система должна отслеживать прогресс: какие элементы просмотрены/завершены.
- Для текстового (или видео) материала достаточно отметить факт завершения/просмотра.
- Для тестового блока (квиза) пользователь должен иметь возможность отправить ответы. Система должна определить количество правильных (набор правильных заранее хранится внутри элемента) и пометить элемент как завершённый только после проверки. Детали хранения формата вопросов — на усмотрение автора (например, одиночный выбор).
- Должна быть возможность запросить прогресс пользователя по курсу: количество завершённых элементов относительно общего числа и процент выполнения (не выше 100%).
- Должна быть возможность получить статус конкретного элемента для пользователя: НЕ НАЧАТ, В ПРОЦЕССЕ (если применимо), ЗАВЕРШЁН.
- Добавление нового типа учебного элемента (например, "Видео") не должно требовать переписывания кода, отвечающего за общую обработку списка содержимого (должна быть предусмотрена полиморфная точка расширения).

## Допущения
- Хранение можно реализовать в памяти (без файлов и баз данных).

## Опционально (Nice to have)
- Итоговый "балл" курса (например, % правильных ответов по квизам).
- Ограничение на порядок: нельзя завершить следующий элемент до предыдущего.
- Отчёт по всем пользователям и их проценту завершения курса.
- Возможность "сбросить" прогресс пользователя по курсу.

## Пример ожидаемого сценария
```python
# Пример ожидаемого сценария использования библиотеки платформы онлайн-курсов

# Создаём курс
course = Course("Python для начинающих")

# Добавляем уроки и тесты
course.add_content(Lesson("Введение", "Что такое Python?"))
course.add_content(Lesson("Переменные", "Как создавать переменные"))

# Регистрируем пользователя
user = User(user_id="u1", name="Алиса")

# Пользователь начинает прохождение курса
progress = CourseProgress(user, course)

# Отмечаем просмотр первого урока
progress.complete_content("Введение")

# Проверяем статус урока
print(progress.get_content_status("Введение"))  # -> "ЗАВЕРШЁН"

# Отмечаем просмотр второго урока
progress.complete_content("Переменные")

# Проходим тест (отправляем ответы)
result = progress.submit_quiz("Тест по переменным", answers=["a = 5"])
print("Правильных ответов:", result["correct"])  # -> 1

# Проверяем статус теста
print(progress.get_content_status("Тест по переменным"))  # -> "ЗАВЕРШЁН"

# Получаем общий прогресс по курсу
print(progress.get_course_progress())
# -> {'completed': 3, 'total': 3, 'percent': 100}

# Пробуем пройти несуществующий элемент
try:
    progress.complete_content("Функции")
except ContentNotFoundError:
    print("Такого элемента нет в курсе")

# Пробуем зарегистрировать пользователя с тем же id
try:
    User(user_id="u1", name="Боб")
except UserAlreadyExistsError:
    print("Пользователь с таким id уже есть")
```

## Критерий приемки
- Создание курса и добавление разнотипных элементов работает.
- Регистрация пользователя и отслеживание его прогресса по курсу функционирует.
- Завершение простого элемента и прохождение тестового элемента различаются по логике (тест требует проверки).
- Процент прогресса считается корректно.
- Расширение новыми типами контента не приводит к дописыванию кода в существующие классы.

# Вариант 4: "Сервис доставки еды"

Предметная область: Построение онлайн курса, отслеживание прогресса пользователя по прохождению этого курса

## Цель
Смоделировать сервис заказа и доставки еды

## Обязательные операции 
- Система должна позволять создать заказ, указав список позиций (название блюда, цена, количество). Заказу присваивается уникальный идентификатор.
- Должна быть возможность получить перечень всех заказов с их составом и итоговой стоимостью.
- Для каждой позиции в заказе должна храниться информация о названии, цене за единицу и количестве.
- Итоговая стоимость заказа должна рассчитываться автоматически с учётом всех позиций. Система должна поддерживать возможность применения различных стратегий расчёта стоимости (например, базовая, с промокодом, с оптовой скидкой). Формулы расчёта должны быть реализованы так, чтобы при добавлении новых стратегий не приходилось переписывать существующий код расчёта.
- Система должна позволять провести оплату заказа, фиксируя способ оплаты (например, банковская карта, подарочный сертификат). Если заказ уже оплачен, повторная попытка оплаты должна приводить к ошибке.
- Должна быть возможность получить статус заказа: создан, оплачен, отменён.

## Допущения
- Хранение можно реализовать в памяти (без файлов и баз данных).

## Опционально (Nice to have)
- Добавить учёт клиентов (имя, id).
- Вести историю всех заказов и оплат.
- Реализовать отчёты по дням/месяцам.
- Поддержка нескольких способов оплаты.
- Возможность экспортировать заказ в JSON или CSV.

## Пример ожидаемого сценария
```python
# Создаём заказ
order = Order()
order.add_item("Пицца Маргарита", price=500, quantity=2)
order.add_item("Салат Цезарь", price=300, quantity=1)

# Применяем стратегию расчёта стоимости (например, промокод)
order.set_pricing_strategy(PromoCodePricing(code="SALE20"))  # скидка 20%

# Получаем итоговую стоимость
print("Итоговая стоимость заказа:", order.get_total())  # например, 1040

# Проводим оплату банковской картой
payment = CardPaymentProcessor()
order.pay(payment)

print("Статус заказа:", order.get_status())  # -> "ОПЛАЧЕН"

# Пробуем оплатить повторно
try:
    order.pay(payment)
except AlreadyPaidError:
    print("Заказ уже оплачен")

# Получаем состав заказа
for item in order.get_items():
    print(f"{item.name}: {item.quantity} шт. по {item.price} руб.")

# Пробуем добавить позицию с некорректными данными
try:
    order.add_item("", price=-100, quantity=0)
except InvalidItemError:
    print("Ошибка: некорректные данные позиции")

# Экспорт заказа в JSON
exporter = JsonOrderExporter()
print(exporter.export(order))
```

## Критерий приемки
- Все перечисленные обязательные возможности реализованы.
- Ошибочные случаи обрабатываются явно.
- Код структурирован: отдельные объекты для заказа, позиции, стратегии расчёта и оплаты.
- Стоимость заказа рассчитывается корректно для всех стратегий.
